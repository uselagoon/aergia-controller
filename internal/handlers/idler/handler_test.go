package idler

import (
	"os"
	"reflect"
	"testing"

	"gopkg.in/yaml.v2"
	"k8s.io/apimachinery/pkg/selection"
)

func TestSelectorsYaml(t *testing.T) {
	var testCases = map[string]struct {
		input       string
		description string
		expect      Data
	}{
		"valid-yaml": {
			input:       "testdata/valid-selectors.yaml",
			description: "This test checks that a valid selectors file is parsed",
			expect: Data{
				NamespaceSelectorsLabels: NamespaceSelectorsLabels{
					ProjectName:       "lagoon.sh/project",
					EnvironmentName:   "lagoon.sh/environment",
					ProjectIdling:     "lagoon.sh/projectAutoIdle",
					EnvironmentIdling: "lagoon.sh/environmentAutoIdle",
					EnvironmentType:   "lagoon.sh/environmentType",
				},
				ServiceName: "lagoon.sh/service",
				CLI: CLI{
					SkipBuildCheck:   false,
					SkipCronCheck:    false,
					SkipProcessCheck: false,
					Namespace: []idlerSelector{
						{
							Name:     "lagoon.sh/environmentType",
							Operator: selection.Operator("in"),
							Values:   []string{"production", "development"},
						},
					},
					Builds: []idlerSelector{
						{
							Name:     "lagoon.sh/jobType",
							Operator: selection.Operator("in"),
							Values:   []string{"build"},
						},
					},
					Deployments: []idlerSelector{
						{
							Name:     "job-name",
							Operator: selection.Operator("!"),
						},
						{
							Name:     "lagoon.sh/service",
							Operator: selection.Operator("in"),
							Values:   []string{"cli"},
						},
					},
					Pods: []idlerSelector{
						{
							Name:     "job-name",
							Operator: selection.Operator("!"),
						},
						{
							Name:     "lagoon.sh/service",
							Operator: selection.Operator("in"),
							Values:   []string{"cli"},
						},
					},
				},
				Service: Service{
					SkipBuildCheck:   false,
					SkipHitCheck:     false,
					SkipIngressPatch: false,
					Namespace: []idlerSelector{
						{
							Name:     "lagoon.sh/environmentType",
							Operator: selection.Operator("in"),
							Values:   []string{"development"},
						},
					},
					Builds: []idlerSelector{
						{
							Name:     "lagoon.sh/jobType",
							Operator: selection.Operator("in"),
							Values:   []string{"build"},
						},
					},
					Deployments: []idlerSelector{
						{
							Name:     "run",
							Operator: selection.Operator("!="),
							Values:   []string{"storage-calc"},
						},
						{
							Name:     "lagoon.sh/service",
							Operator: selection.Operator("notin"),
							Values:   []string{"cli"},
						},
						{
							Name:     "lagoon.sh/service-type",
							Operator: selection.Operator("notin"),
							Values:   []string{"mariadb-single", "postgres-single", "mongodb-single"},
						},
						{
							Name:     "lagoon.sh/jobType",
							Operator: selection.Operator("notin"),
							Values:   []string{"build"},
						},
						{
							Name:     "lagoon.sh/environment",
							Operator: selection.Operator("exists"),
						},
					},
					Pods: []idlerSelector{
						{
							Name:     "run",
							Operator: selection.Operator("!="),
							Values:   []string{"storage-calc"},
						},
						{
							Name:     "lagoon.sh/service",
							Operator: selection.Operator("notin"),
							Values:   []string{"cli"},
						},
						{
							Name:     "lagoon.sh/service-type",
							Operator: selection.Operator("notin"),
							Values:   []string{"mariadb-single", "postgres-single", "mongodb-single"},
						},
						{
							Name:     "lagoon.sh/jobType",
							Operator: selection.Operator("notin"),
							Values:   []string{"build"},
						},
						{
							Name:     "lagoon.sh/environment",
							Operator: selection.Operator("exists"),
						},
					},
					Ingress: []idlerSelector{
						{
							Name:     "lagoon.sh/autogenerated",
							Operator: selection.Operator("exists"),
						},
					},
				},
			},
		},
	}
	for name, tc := range testCases {
		t.Run(name, func(tt *testing.T) {
			file, err := os.Open(tc.input)
			if err != nil {
				tt.Fatal(err)
			}
			defer file.Close()
			d := yaml.NewDecoder(file)
			selectors := &Data{}
			if err := d.Decode(&selectors); err != nil {
				tt.Fatal(err)
			}
			if !reflect.DeepEqual(*selectors, tc.expect) {
				tt.Fatalf("Read selectors does not match expected selectors")
			}
		})
	}
}
